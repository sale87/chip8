
- [x] 3xnn - if vX == nn, skip next opcode
- [x] 4xnn - if vX != nn, skip next opcode
- [x] 5xy0 - if vX == vY, skip next opcode
- [x] 7xnn - vX += nn
- [x] 9xy0 - if vX != vY, skip next opcode
- [x] 1nnn - jump nnn (goto)
- [x] 2nnn - call nnn (subroutine)
- [x] 00EE - return from subroutine
- [x] 8xy0 - vX = vY
- [x] 8xy1 - vX |= vY
- [x] 8xy2 - vX &= vY
- [x] 8xy3 - vX ^= vY
- [x] 8xy4 - vX += vY
- [x] 8xy5 - vX -= vY
- [x] 8xy7 - vX = vY - vX
- [x] 8xy6 - vX = vY >> 1 or vX = vX >> 1 depending on quirks
- [x] 8xyE - vX = vY << 1 or vX = vX << 1 depending on quirks
- [x] Fx65 - load registers v0 - vX from memory starting at i
- [x] Fx55 - save registers v0 - vX to memory starting at i
- [x] Fx33 - store binary-coded decimal representation of vX to memory at i, i + 1 and i + 2
- [x] Fx1E - i += vX
- [ ] Registers - The v0 - vF registers should be 8 bits wide. This tests to see if it can overflow your registers.
